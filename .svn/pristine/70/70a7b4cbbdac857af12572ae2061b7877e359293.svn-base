#ifndef Room_H
#define Room_H

//parallel for
#include "parallelhandle.h"

#include <QTime>

#include "animation.h"
#include "modelstructure.h"

using namespace glm;

//urobiť kopirovaci konštruktor
class Room
{
    //basic parameters for project
    std::string Name;
    vec3 RoomDimensions; //centimeters
    double Epsilon;
    bool Saved;

    ModelStructure *Structure;
    std::vector <Edge> CamTopology;
    std::vector <CaptureCamera*> cameras;

    double DistanceTemp;
    std::vector<std::vector<Line> > Lines;
    std::vector<std::vector<Line> > Lines_copy;

    vec3 PointClosest, PointClosest2;
    std::vector<vec3> UnmarkedPoints;

    size_t ActiveCams;
    size_t ActiveCamIndex;

    bool Record, CaptureAnimation;
    Animation* ActualAnimation;
    std::vector<Animation*> Animations;

    bool Pipe;
    int fd;

    ParallelIntersections * paralel;

    QTime Timer, FrameTimer;

    OpenGLWindow *Opengl;
public:
    Room(OpenGLWindow *opengl = NULL, vec3 dimensions = vec3(0.0f,0.0f, 0.0f), float eps = 0.5, std::string name = "Default Project");
    Room(std::string file);
    ~Room();

    void AddCamera(vec3 pos, std::string name, int ID,int angle);
    void AddCamera(CaptureCamera *cam);
    void RemoveCamera(size_t index);
    void MakeTopology();
    void Save(std::ofstream &file);

    void TurnOnCamera(size_t index);
    void TurnOffCamera(size_t index);
    void ShowCameraVideo(size_t index){cameras[index]->Show();}
    void HideCameraVideo(size_t index){cameras[index]->Hide();}

    void CaptureAnimationStart();
    void setPipe(bool pipe);
    Animation *CaptureAnimationStop();
    void RecordingStart();
    void RecordingStop();
    std::vector<vec3> RecordNextFrame();

    void setDimensions(vec3 dims);
    void setName(std::string name){this->Name = name;}
    void setEpsilon(float size);

    ModelStructure* getStructure() const {return Structure;}
    std::string getName() const {return Name;}
    vec3 getDimensions() const {return RoomDimensions;}
    int getWidth()const {return RoomDimensions.x;}
    int getLength()const {return RoomDimensions.y;}
    float getEpsilon() const {return Epsilon;}
    bool getSaved() const {return Saved;}
    std::vector<std::vector<Line> > getLines() const {return Lines_copy;}
    std::vector <CaptureCamera*> getcameras()const {return cameras;}

    void setOpenglWindow(OpenGLWindow * opengl) {Opengl = opengl;}
    void setStructure(ModelStructure* struc) {Structure = struc;}
    void setThreshold(int value);
    void setBrighnessOfCamera(int value);

private:

};

#endif // Room_H
