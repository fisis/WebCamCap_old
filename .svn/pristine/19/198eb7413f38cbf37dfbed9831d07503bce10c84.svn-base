#include "openglwindow.h"
#include <iostream>
#include <GL/glu.h>
#include <GL/glut.h>

#include <QDir>

OpenGLWindow::OpenGLWindow(QWidget *parent) : QGLWidget(parent)
{
    zoom = 1.0f;
    drawJoints = true;
    drawLines = true;
    drawBones = true;
    roomDims = vec3(100.0f, 100.0f, 100.0f);
    camRot = vec3(0.0f, 0.0f, 0.0f);

    //mouse
    currentMousePos = lastMousePos = vec2(0.0f, 0.0f);
    leftButton = false;

    //QImage temp(QDir::currentPath() + "/Pictures/checkboard_texture.jpg");

    //texture = QGLWidget::convertToGLFormat(temp);
}

void OpenGLWindow::initializeGL()
{
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);

    glShadeModel(GL_SMOOTH);
    glRenderMode(GL_RENDER);

    glPolygonMode(GL_FRONT, GL_FILL);
    glPolygonMode(GL_BACK, GL_FILL);

    glEnable(GL_POLYGON_SMOOTH);
    glHint(GL_POLYGON_SMOOTH_HINT,GL_NICEST);

/*
    glEnable(GL_TEXTURE_2D);
    glGenTextures(1, &texId);
    glBindTexture(GL_TEXTURE_2D, texId);

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);

    glTexImage2D( GL_TEXTURE_2D, 0, GL_RGBA, texture.width(), texture.height(), 0, GL_RGBA, GL_UNSIGNED_BYTE, texture.bits() );

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

    glDisable(GL_TEXTURE_2D);
*/
}

void OpenGLWindow::paintGL()
{
    glClearColor(0.15f, 0.15f, 0.15f, 1);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glLoadIdentity();

    gluLookAt(
                -roomDims.x*zoom, 200*zoom, roomDims.y*zoom,
                 roomDims.x/2.0f, roomDims.z/2.0f , -roomDims.y/2.0f,
                 0, 1, 0
                    );

    glTranslatef(roomDims.x/2.0f, roomDims.z/2.0f, -roomDims.y/2.0f);
    glRotatef(camRot.x, 1, 0, 0);
    glRotatef(camRot.y, 0, 1, 0);
    glTranslatef(-roomDims.x/2.0f, -roomDims.z/2.0f, roomDims.y/2.0f);

    if(drawJoints)
    {
        drawJoints();
    }

    if(drawLines)
    {
        drawLines();
    }

    if(drawBones)
    {
        drawBones();
    }

    drawFloor();
}

void OpenGLWindow::resizeGL(int w, int h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(60, (float) w/ (float) h, 0.1, 10000);

    glMatrixMode(GL_MODELVIEW);
}

void OpenGLWindow::setRoomDims(vec3 dims)
{
    roomDims = dims;
    updateGL();
}

void OpenGLWindow::setFrame(std::vector<std::vector<Line> > lns, std::vector<vec3> pts, std::vector<Line> bns)
{
    joints = pts;
    lines = lns;
    bones = bns;

    updateGL();
}

void OpenGLWindow::wheelEvent(QWheelEvent *event)
{
    int numDegrees = -event->delta() / 8;
    int numSteps = numDegrees / 15;

    zoom += 0.1*numSteps;

    if(zoom < 0.5)
    {
        zoom = 0.5;
    }
    else if(zoom > 5.0)
    {
        zoom = 5.0;
    }

    updateGL();
    event->accept();
}

void OpenGLWindow::mousePressEvent(QMouseEvent *event)
{
    if(event->button() == Qt::LeftButton)
    {
        QCursor c = cursor();
        c.setShape(Qt::DragMoveCursor);
        setCursor(c);

        leftButton = true;
        currentMousePos.x = event->x();
        currentMousePos.y = event->y();
    }

    event->accept();
}

void OpenGLWindow::mouseReleaseEvent(QMouseEvent *event)
{
    if(event->button() == Qt::LeftButton)
    {
        QCursor c = cursor();
        c.setShape(Qt::OpenHandCursor);
        setCursor(c);

        leftButton = false;

    }

    event->accept();
}

void OpenGLWindow::mouseMoveEvent(QMouseEvent *event)
{
    if(leftButton)
    {
        lastMousePos = currentMousePos;

        currentMousePos.x = event->x();
        currentMousePos.y = event->y();

        camRot.y += (currentMousePos.x - lastMousePos.x);
        camRot.z = camRot.x += (currentMousePos.y - lastMousePos.y);

        limitsCamRot();
    }

    updateGL();
    event->accept();
}

void OpenGLWindow::limitsCamRot()
{
    if(camRot.y >= 360.0f)
    {
        camRot.y -= 360.0f;
    }

    if(camRot.y <= 360.0f)
    {
        camRot.y += 360.0f;
    }

    if(camRot.x > 30.0f)
    {
        camRot.x  = 30.0f;
    }

    if(camRot.x < -30.0f)
    {
        camRot.x  = -30.0f;
    }
}

void OpenGLWindow::countView()
{

}

void OpenGLWindow::drawLine(Line l)
{
    glBegin(GL_LINES);
    glVertex3f(l.position.x, l.position.z, -l.position.y);
    glVertex3f(l.position.x+2*l.directionVector.x, l.position.z+2*l.directionVector.z, -1*(l.position.y+2*l.directionVector.y));
    glEnd();
}

void OpenGLWindow::drawLines()
{
    glColor3f(1.0f,0.5f,0.0f);

    for(size_t i = 0; i < lines.size(); i++)
    {
        for(size_t j = 0; j < lines[i].size(); j++)
        {
            drawLine(lines[i][j]);
        }
    }
}

void OpenGLWindow::drawJoints()
{
    glColor3f(1,1,1);

    glPushMatrix();
    for(size_t i = 0; i < joints.size(); i++)
    {
        glTranslatef(joints[i].x, joints[i].z, -joints[i].y);
        glutSolidSphere(3, 8, 8);
        glTranslatef(-joints[i].x, -joints[i].z, joints[i].y);
    }
    glPopMatrix();
}

void OpenGLWindow::drawBones()
{
    for(size_t i = 0; i < bones.size(); i++)
    {
        drawLine(bones[i]);
    }
}

void OpenGLWindow::drawFloor()
{
    glColor3f(0.2, 0.1, 0.7);

    glBegin(GL_QUADS);
    glTexCoord2f(0,0); glVertex3d(0, -1, 0);
    glTexCoord2f(1,0); glVertex3d(roomDims.x, -1, 0);
    glTexCoord2f(1,1); glVertex3d(roomDims.x, -1, -roomDims.y);
    glTexCoord2f(0,1); glVertex3d(0, -1, -roomDims.y);
    glEnd();
}

void OpenGLWindow::DefaultView()
{

}


void OpenGLWindow::loadTexture()
{

}
