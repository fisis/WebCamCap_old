#include "room.h"
#include <opencv2/opencv.hpp>

Room::Room(vec3 dimensions, float eps, std::string name)
{
    if(dimensions == vec3(0, 0, 0) && eps == 0.5 &&  name == "Default Project")
    {
        Saved = true;
    }
    else
    {
        Saved = false;
    }

    Name = name;
    RoomDimensions = dimensions;

    std::cout << RoomDimensions << std::endl;

    Epsilon  = eps;

    ActiveCams = 0;
    ActiveCamIndex = 0;
}

Room::Room(std::string file)
{
    std::ifstream inputFile;
    inputFile.open(file);

    std::getline(inputFile, Name);

    std::string line;
    std::stringstream linestream;

    std::getline(inputFile, line);
    linestream << line;

    linestream >> RoomDimensions.x;
    linestream >> RoomDimensions.y;
    linestream >> RoomDimensions.z;
    linestream >> Epsilon;
    linestream.flush();

    size_t numOfCams;
    std::stringstream linestream2;
    std::getline(inputFile, line);
    linestream2 << line;

    linestream2 >> numOfCams;

    for(size_t i = 0; i < numOfCams; i++)
    {
        std::stringstream linestream3;
        std::getline(inputFile,line);
        linestream3 << line;

        std::string tname;
        linestream3 >>  tname;

        vec3 tposition;
        linestream3 >> tposition.x;
        linestream3 >> tposition.y;
        linestream3 >> tposition.z;

        int tID;
        linestream3 >> tID;

        float tAngle;
        linestream3 >> tAngle;

        vec2 resolution;
        linestream3 >> resolution.x;
        linestream3 >> resolution.y;

        CaptureCamera* temp = new CaptureCamera(tposition, RoomDimensions, tname, tID, tAngle);

        temp->resolution = resolution;

        AddCamera(temp);
        TurnOnCamera(cameras.size()-1);
        ShowCameraVideo(cameras.size()-1);
        cameras[i]->CalibNoMarkers();

    }

    inputFile.close();

    ActiveCams = 0;
    ActiveCamIndex = 0;

    Saved = true;
}

Room::~Room()
{
    for(size_t i = 0; i < cameras.size(); i++)
    {
        cameras[i]->Hide();
        cameras[i]->TurnOff();
        delete(cameras[i]);
    }
}

void Room::AddCamera(CaptureCamera *cam)
{
    cameras.push_back(cam);

    std::vector<Line> tempLines;
    Lines.push_back(tempLines);
    Lines_copy.push_back(tempLines);

    if(cam->getTurnedOn())
    {
        ActiveCams++;
        ActiveCamIndex = cameras.size()-1;
    }

    Saved = false;
}

void Room::AddCamera(vec3 pos, std::string name, int ID, int angle)
{
    CaptureCamera* temp = new CaptureCamera(pos, RoomDimensions, name, ID, angle);

    AddCamera(temp);
}

std::vector<vec3> Room::RecordNextFrame()
{
    for(size_t i = 0; i < cameras.size(); i++)
    {
        Lines[i] = cameras[i]->RecordNextFrame();
        Lines_copy[i] = Lines[i];
    }
    Intersections();
    cv::waitKey(10);

    return UnmarkedPoints;
}

void Room::setDimensions(vec3 dims)
{
    RoomDimensions = dims;

    for(size_t i = 0; i < cameras.size(); i++)
    {
        cameras[i]->setDimensions(dims);
    }

    Saved = false;
}

void Room::setEpsilon(float size)
{
    Epsilon = size;
    Saved = false;
}

void Room::RemoveCamera(size_t index)
{
    HideCameraVideo(index);
    TurnOffCamera(index);
    cameras.erase(cameras.begin()+index);
    Saved = false;
}

void Room::TurnOnCamera(size_t index)
{
    cameras[index]->TurnOn();
    ActiveCams++;
    ActiveCamIndex = index;
    Saved = false;
}

void Room::TurnOffCamera(size_t index)
{
    cameras[index]->TurnOff();
    ActiveCams--;
    Saved = false;
}

void Room::Save(std::ofstream &file)
{
    //save dimension and epsilon of room
    file << RoomDimensions.x << " " << RoomDimensions.y << " " << Epsilon << std::endl;
    file << cameras.size() << std::endl;

    for(size_t i = 0; i < cameras.size(); i++)
    {
        cameras[i]->Save(file);
    }

    //set project as saved
    Saved = true;
}

void Room::setThreshold(int value)
{
    for(size_t i = 0; i < cameras.size(); i++)
    {
        cameras[i]->setThreshold(value);
    }

    Saved = false;
}

void Room::Intersections()
{
    UnmarkedPoints.clear();

    if(ActiveCams == 1)
    {
        Line cameraPlane(vec3(RoomDimensions.x/2.0f, RoomDimensions.y/2.0f, 0.0f), cameras[ActiveCamIndex]->getDirVector());

        for(size_t i = 0; i < Lines[0].size(); i++)
        {
            PointClosest = Line::IntersectionLinePlane(Lines[0][i], cameraPlane);
            UnmarkedPoints.push_back(PointClosest);
        }
        return;
    }

    for(size_t i = 0; i < Lines.size(); i++)
        for(size_t j = 0; j < Lines[i].size(); j++)
        {
            for(size_t k = i+1; k < Lines.size(); k++)
                for(size_t l = 0; l < Lines[k].size(); l++)
                {
                        /*for(size_t c = 0; c < UnmarkedPoints.size(); c++)
                        {
                            //ak je priamka blizko bodu vyberiem ju a spriemerujem hodnoty
                            //ak je viac ako 2 kamery
                        }*/

                        Line::ClosestPointsOnTwoLines(Lines[i][j],Lines[k][l], point1, point2);
                        if(Epsilon > Line::DistanceTwoPoints(point1, point2))
                        {
                            Lines[i][j].Intersections += 1;
                            Lines[k].erase(Lines[k].begin() + l);

                            //ak je viac priesecnikov vyberam najblizsi ku kamere
                            if(Lines[i][j].Intersections == 1)
                                PointClosest = Line::AveragePoint(point1, point2);
                            else
                            {
                                PointClosest2 = Line::AveragePoint(point1, point2);
                                if(Line::DistanceTwoPoints(PointClosest, cameras[i]->getPosition()) >
                                   Line::DistanceTwoPoints(PointClosest2, cameras[i]->getPosition()) )
                                    PointClosest = PointClosest2;
                            }
                        }
                }

            //poznacit ze uÅ¾ vytvorila bod
            if(Lines[i][j].Intersections > 0)
                UnmarkedPoints.push_back(PointClosest);
        }
}

void Room::setBrighnessOfCamera(int value)
{
    for(size_t i = 0; i < cameras.size(); i++)
    {
        cameras[i]->setBrightness(value);
    }

    Saved = false;
}

//operatorr
