#include "room.h"

//include for pipe
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

#include <QApplication>

Room::Room(OpenGLWindow *opengl, vec3 dimensions, float eps, std::string name)
{
    if(dimensions == vec3(0.0f, 0.0f, 0.0f) && eps == 0.5 &&  name == "Default Project")
    {
        Saved = true;
    }
    else
    {
        Saved = false;
    }

    Opengl = opengl;
    Name = name;
    RoomDimensions = dimensions;

    std::cout << RoomDimensions << std::endl;

    Pipe = CaptureAnimation = Record = false;

    Epsilon  = eps;

    ActiveCams = 0;
    ActiveCamIndex = 0;
}

Room::Room(std::string file)
{
    std::ifstream inputFile;
    inputFile.open(file);

    std::getline(inputFile, Name);

    std::string line;
    std::stringstream linestream;

    std::getline(inputFile, line);
    linestream << line;

    linestream >> RoomDimensions.x;
    linestream >> RoomDimensions.y;
    linestream >> RoomDimensions.z;
    linestream >> Epsilon;
    linestream.flush();

    size_t numOfCams;
    std::stringstream linestream2;
    std::getline(inputFile, line);
    linestream2 << line;

    linestream2 >> numOfCams;

    for(size_t i = 0; i < numOfCams; i++)
    {
        std::stringstream linestream3;
        std::getline(inputFile,line);
        linestream3 << line;

        std::string tname;
        linestream3 >>  tname;

        vec3 tposition;
        linestream3 >> tposition.x;
        linestream3 >> tposition.y;
        linestream3 >> tposition.z;

        int tID;
        linestream3 >> tID;

        float tAngle;
        linestream3 >> tAngle;

        vec2 resolution;
        linestream3 >> resolution.x;
        linestream3 >> resolution.y;

        CaptureCamera* temp = new CaptureCamera(tposition, RoomDimensions, tname, tID, tAngle);

        temp->resolution = resolution;

        AddCamera(temp);
        TurnOnCamera(cameras.size()-1);
        ShowCameraVideo(cameras.size()-1);
        cameras[i]->CalibNoMarkers();

    }

    inputFile.close();

    ActiveCams = 0;
    ActiveCamIndex = 0;

    Saved = true;
}

Room::~Room()
{
    for(size_t i = 0; i < cameras.size(); i++)
    {
        cameras[i]->Hide();
        cameras[i]->TurnOff();
        delete(cameras[i]);
    }

    for(size_t i = 0; i < Animations.size(); i++)
    {
        delete(Animations[i]);
    }
}

void Room::AddCamera(CaptureCamera *cam)
{
    cameras.push_back(cam);

    std::vector<Line> tempLines;
    Lines.push_back(tempLines);
    Lines_copy.push_back(tempLines);

    if(cam->getTurnedOn())
    {
        ActiveCams++;
        ActiveCamIndex = cameras.size()-1;
    }

    Saved = false;

    MakeTopology();
}

void Room::AddCamera(vec3 pos, std::string name, int ID, int angle)
{
    CaptureCamera* temp = new CaptureCamera(pos, RoomDimensions, name, ID, angle);

    AddCamera(temp);
}

std::vector<vec3> Room::RecordNextFrame()
{
    /*
    Timer.start();

    for(size_t i = 0; i < cameras.size(); i++)
    {
        Lines[i] = cameras[i]->RecordNextFrame();
        Lines_copy[i] = Lines[i];
    }

    Intersections();
    int waitTime = 33 - Timer.elapsed();

    if(waitTime > 0)
    {
        cv::waitKey(waitTime);
    }
    else
    {
        cv::waitKey(1);
    }
    std::cout << waitTime << std::endl;
    Timer.restart();

    return UnmarkedPoints;*/
}

void Room::setDimensions(vec3 dims)
{
    RoomDimensions = dims;

    for(size_t i = 0; i < cameras.size(); i++)
    {
        cameras[i]->setDimensions(dims);
    }

    Saved = false;
}

void Room::setEpsilon(float size)
{
    Epsilon = size;
    Saved = false;
}

void Room::RemoveCamera(size_t index)
{
    HideCameraVideo(index);
    TurnOffCamera(index);
    cameras.erase(cameras.begin()+index);
    Saved = false;

    MakeTopology();
}

void Room::MakeTopology()
{
    CamTopology.clear();

    vec3 pos1, pos2;
    vec3 dir1, dir2;

    float min = -181.0f, max = 181.0f, temp_angle;
    int min_index = -1, max_index = -1;

    //get
    for(size_t i = 0; i < cameras.size(); i++)
    {
        pos1 = cameras[i]->getPosition();
        dir1 = cameras[i]->getDirVector();

        for(size_t j = i+1; j < cameras.size(); j++)
        {
            pos2 = cameras[j]->getPosition();
            dir2 = cameras[j]->getDirVector();

            temp_angle = Line::LineAngle(vec2(dir1.x, dir1.y),vec2(dir2.x, dir2.y));

            if(temp_angle < 0)
            {
                if(temp_angle > min)
                {
                    min = temp_angle;
                    min_index = j;
                }
            }
            else
            {
                if(temp_angle < max)
                {
                    max = temp_angle;
                    max_index = j;
                }
            }
        }

        if(min_index != -1)
        {
            CamTopology.push_back(Edge(i,min_index, Epsilon));
        }

        if(max_index != -1)
        {
            CamTopology.push_back(Edge(i,max_index, Epsilon));
        }
    }
}

void Room::TurnOnCamera(size_t index)
{
    cameras[index]->TurnOn();
    ActiveCams++;
    ActiveCamIndex = index;
    Saved = false;
}

void Room::TurnOffCamera(size_t index)
{
    cameras[index]->TurnOff();
    ActiveCams--;
    Saved = false;
}

void Room::CaptureAnimationStart()
{

    ActualAnimation = new Animation(Epsilon);
}

void Room::setPipe(bool pipe)
{
    char * myfifo = "/tmp/myfifo";

    if(pipe)
    {
        Pipe = false;
        ::close(fd);
        unlink(myfifo);
    }
    else
    {
        Pipe = true;

        /* create the FIFO (named pipe) */
        mkfifo(myfifo, 0666);

        /* write "Hi" to the FIFO */
        fd = open(myfifo, O_WRONLY);
        fcntl(fd,F_SETFL,0);
    }
}

Animation *Room::CaptureAnimationStop()
{
    Animations.push_back(ActualAnimation);

    Animation * ret = ActualAnimation;

    ActualAnimation = NULL;

    return ret;
}

void Room::RecordingStart()
{
    Record = true;

    paralel = new ParallelIntersections(cameras, Epsilon, CamTopology, Opengl);

/*
    while(Record)
    {
        QApplication::processEvents();

        RecordNextFrame();
        //ui->OpenGLWIndow->setFrame(Lines,Points);

            if(FrameTimer.isNull())
            {
                FrameTimer.start();
            }
            ActualAnimation->AddFrame(UnmarkedPoints, Lines,FrameTimer.elapsed());

            //std::cout << LastFrameTime.elapsed() << std::endl;

            FrameTimer.restart();

        if(Pipe)
        {
            std::string msg = ("Hi\n");

            write(fd, msg.c_str()  , msg.size() );
            std::cout << msg;
        }
    }*/
}

void Room::RecordingStop()
{
    Record = false;

    delete paralel;
}

void Room::Save(std::ofstream &file)
{
    //save dimension and epsilon of room
    file << RoomDimensions.x << " " << RoomDimensions.y << " " << Epsilon << std::endl;
    file << cameras.size() << std::endl;

    for(size_t i = 0; i < cameras.size(); i++)
    {
        cameras[i]->Save(file);
    }

    //set project as saved
    Saved = true;
}

void Room::setThreshold(int value)
{
    for(size_t i = 0; i < cameras.size(); i++)
    {
        cameras[i]->setThreshold(value);
    }

    Saved = false;
}

/*
void Room::Intersections(std::vector<Line> Lines1, std::vector<Line> Lines2)
{
    std::vector<vec3> UnmarkedPoints;

    if(ActiveCams == 1)
    {
        Line cameraPlane(vec3(RoomDimensions.x/2.0f, RoomDimensions.y/2.0f, 0.0f), cameras[ActiveCamIndex]->getDirVector());

        for(size_t i = 0; i < Lines[0].size(); i++)
        {
            PointClosest = Line::IntersectionLinePlane(Lines[0][i], cameraPlane);
            UnmarkedPoints.push_back(PointClosest);
        }
        return;
    }

    for(size_t i = 0; i < Lines.size(); i++)
        for(size_t j = 0; j < Lines[i].size(); j++)
        {
            for(size_t k = i+1; k < Lines.size(); k++)
            {
                for(size_t l = 0; l < Lines[k].size(); l++)
                {
                    if(!Lines[k][l].Found)
                    {
                        Intersection(Lines[i][j],Lines[k][l], cameras[i]->getPosition());
                    }
                }
            }


            //poznacit ze uÅ¾ vytvorila bod
            if(Lines[i][j].Intersections > 0)
                UnmarkedPoints.push_back(PointClosest);
        }
}
*/

void Room::setBrighnessOfCamera(int value)
{
    for(size_t i = 0; i < cameras.size(); i++)
    {
        cameras[i]->setBrightness(value);
    }

    Saved = false;
}

void Room::sendMessage(std::vector<vec3> Points)
{
    std::stringstream ss;

    ss << "# ";

    for(size_t i = 0; i < Points.size(); i++)
    {
        ss << "P" << Points[i];
    }

    std::string msg = ss.str();

    write(fd, msg.c_str()  , msg.size() );
}
