#ifndef PARALLELHANDLE_H
#define PARALLELHANDLE_H

#include <opencv2/opencv.hpp>
#include <queue>

#include "openglwindow.h"
#include "capturecamera.h"

#include <QtCore>
#include <QTime>
#include <QApplication>


using namespace glm;

class CaptureThread : public QThread
{
    Q_OBJECT

    volatile bool abort;

    CaptureCamera *Cam;
    QMutex mutex;
    QWaitCondition condition;
    QWaitCondition * line;

    std::vector<Line> Result;
public:
    CaptureThread(QWaitCondition *q, CaptureCamera *cam, QThread *parent = NULL);
    ~CaptureThread();

signals:
  void ResultReady(std::vector<Line> lines);

private slots:

private:

  void run();
};

typedef struct Edge
{
    Edge(int a, int b, float Eps): index_a(a), index_b(b), Epsilon(Eps) {}

    int index_a, index_b;
    std::vector<Line> a;
    std::vector<Line> b;
    float Epsilon;
    std::vector <vec3> Points;
} Edge;

class ParallelIntersections : public QObject
{
    Q_OBJECT


    QMutex mutex;
    QWaitCondition allLines;

    //cams
    std::vector <bool> haveResults;
    std::vector <std::vector<Line> > Results;
    std::vector <vec3> Points;

    std::vector <CaptureCamera*> cameras;
    std::vector <CaptureThread*> camThreads;

    //intersections
    float Epsilon;
    QList<Edge> Topology;

    QTime timer;
    OpenGLWindow *Opengl;
public:
    ParallelIntersections(std::vector <CaptureCamera*> cams, float epsilon, const std::vector<Edge> &topology, OpenGLWindow * opengl);
    ~ParallelIntersections();

signals:
    //void nextFrame(const bool &n);

private slots:
    void ResultReady(std::vector<Line> lines);

private:
    static void Intersection(Edge &camsEdge);
    void Intersections();
};

#endif // PARALLELHANDLE_H
