#include "parallelhandle.h"

#include <QFutureSynchronizer>
#include <QFutureWatcher>
#include <QFuture>

CaptureThread::CaptureThread(QWaitCondition *q, CaptureCamera *cam, QThread *parent) : QThread(parent)
{
    restart = false;
    abort = false;

    line = q;
    Cam = cam;
}

CaptureThread::~CaptureThread()
{
    mutex.lock();
    abort = true;
    condition.wakeOne();
    mutex.unlock();

    wait();
}

void CaptureThread::run()
{
    forever
    {
        mutex.lock();
        Result = Cam->RecordNextFrame();

        emit ResultReady(Result);
        line->wait(&mutex);
        mutex.unlock();

        if (abort)
        {
            return;
        }
    }
}

ParallelIntersections::ParallelIntersections(std::vector <CaptureCamera*> cams)
{
    cameras = cams;
    //Asycnronous computation

    for(size_t i = 0; i < cameras.size(); i++)
    {
        haveResults.push_back(false);

        camThreads.push_back(new CaptureThread(&allLines, cameras[i]));
        connect(camThreads[i],SIGNAL(ResultReady(std::vector<Line>)),this,SLOT(ResultReady(std::vector<Line>)));
        //connect(camThreads[i],SIGNAL(finished()), camThreads[i], SLOT(deleteLater()));
    }

    for(size_t i = 0; i < cameras.size(); i++)
    {
        camThreads[i]->start();
    }
}

ParallelIntersections::~ParallelIntersections()
{
    for(size_t i = 0; i < camThreads.size(); i++)
    {
        delete camThreads[i];
    }
}

void ParallelIntersections::ResultReady(std::vector<Line> lines)
{
    waitKey(1);

    QObject *obj = QObject::sender();

    for(size_t i = 0; i < camThreads.size(); i++)
    {
        if(obj == camThreads[i])
        {
            if(haveResults[i])
            {
                std::cout << "bad sync" << std::endl;
            }

            haveResults[i] = true;
            std::cout << "have result " << i << std::endl;
        }
    }

    for(size_t i = 0; i < camThreads.size(); i++)
    {
        if(!haveResults[i])
        {
            return;
        }
    }

    Intersections();

    allLines.wakeAll();
}

void ParallelIntersections::Intersections()
{
   std::cout << "i did intersection" << std::endl;

   for(size_t i = 0; i < camThreads.size(); i++)
   {
       haveResults[i] = false;
   }
}
